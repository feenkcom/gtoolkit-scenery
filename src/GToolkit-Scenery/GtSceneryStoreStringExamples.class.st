"
I collect examples validating the behavior of the storeString facility for sceneries.
I also make use of equality for sceneries, ietms, stencils and connections.

GtSceneryEntityStencil expects subclasses to implement #storeOnAttributes listing the attributes to be stored.

Each attribute `x` should have a getter `#x`, a setter `#x:` and also a `#defaultX` method, which is used not only to initialize `x`, but also to check if the value is notthe default one during storeString generation.

Subclasses can use `GtSceneryEntityStencil>>#storeWithAttributesOn:` to implement `#storeOn:`.
"
Class {
	#name : #GtSceneryStoreStringExamples,
	#superclass : #AbstractGtExampleAssertable,
	#category : #'GToolkit-Scenery-Examples'
}

{ #category : #scenery }
GtSceneryStoreStringExamples >> circleShapeScenery [
	"NB: Generated by GtScenery>>#storeAsExampleMethod -- do not edit."

	<gtExample>
	<noTest>
	<storedScenery>
	<return: #GtScenery>
	| scenery item1 |
	scenery := GtScenery new.
	item1 := scenery
			addItem: (GtSceneryShapeStencil new geometry: BlCircleGeometry new) asItem.
	item1 position: 67.74245198567701 @ 69.517333984375.
	item1 extent: 200.0 @ 200.0.
	scenery
		storeStringMethodName: 'GtSceneryStoreStringExamples>>#circleShapeScenery'.
	^ scenery
]

{ #category : #example }
GtSceneryStoreStringExamples >> circleShapeSceneryRestored [
	<gtExample>
	<return: #GtScenery>
	| scenery |
	scenery := self circleShapeScenery.
	self assert: scenery equals: scenery restored.
	^ scenery
]

{ #category : #accessing }
GtSceneryStoreStringExamples >> compositeScenery [
	<gtExample>
	<return: #GtScenery>
	| scenery |
	scenery := self emptyScenery.
	{self circleShapeSceneryRestored.
		self gtBookLabelSceneryRestored.
		self gtLogoFileSceneryRestored.
		self gtSceneryClassSceneryRestored.
		self inspectorOn42SceneryRestored.
		self mindmapBubbleSceneryRestored.
		self textLabelSceneryRestored} do: [ :each | scenery addScenery: each ].
	self assert: scenery equals: scenery restored.
	^ scenery
]

{ #category : #scenery }
GtSceneryStoreStringExamples >> emptyScenery [
	<gtExample>
	<return: #GtScenery>
	| scenery |
	scenery := GtScenery new.
	self assert: scenery items isEmpty.
	self assert: scenery connections isEmpty.
	self assert: scenery equals: GtScenery new.
	^ scenery
]

{ #category : #scenery }
GtSceneryStoreStringExamples >> gtBookLabelScenery [
	"NB: Generated by GtScenery>>#storeAsExampleMethod -- do not edit."

	<gtExample>
	<noTest>
	<storedScenery>
	<return: #GtScenery>
	| scenery item1 |
	scenery := GtScenery new.
	item1 := scenery
			addItem: (GtSceneryLePageTitleLabelStencil new width: 157.8820343017578) asItem.
	item1 position: 73.34053548177076 @ 70.0040181477865.
	item1 extent: 157.8820343017578 @ 28.0.
	scenery
		storeStringMethodName: 'GtSceneryStoreStringExamples>>#gtBookLabelScenery'.
	^ scenery
]

{ #category : #example }
GtSceneryStoreStringExamples >> gtBookLabelSceneryRestored [
	<gtExample>
	<return: #GtScenery>
	| scenery |
	scenery := self gtBookLabelScenery.
	self assert: scenery equals: scenery restored.
	^ scenery
]

{ #category : #example }
GtSceneryStoreStringExamples >> gtExampleMethodWithoutNoTestPragma [
	<gtExample>
	<return: #True>
	^ true
]

{ #category : #scenery }
GtSceneryStoreStringExamples >> gtLogoFileScenery [
	"NB: Generated by GtScenery>>#storeAsExampleMethod -- do not edit."

	<gtExample>
	<noTest>
	<storedScenery>
	<return: #GtScenery>
	| scenery item1 |
	scenery := GtScenery new.
	item1 := scenery
			addItem: (GtSceneryPictureStencil new
					fileReference: FileLocator gtResource / 'feenkcom' / 'gtoolkit' / 'doc' / 'gtoolkit.png')
					asItem.
	item1 position: 114.6820068359375 @ 242.44258626302087.
	item1 extent: 450.0 @ 150.0.
	scenery
		storeStringMethodName: 'GtSceneryStoreStringExamples>>#gtLogoFileScenery'.
	^ scenery
]

{ #category : #example }
GtSceneryStoreStringExamples >> gtLogoFileSceneryRestored [
	<gtExample>
	<return: #GtScenery>
	| scenery |
	scenery := self gtLogoFileScenery.
	self assert: scenery equals: scenery restored.
	^ scenery
]

{ #category : #scenery }
GtSceneryStoreStringExamples >> gtSceneryClassScenery [
	"NB: Generated by GtScenery>>#storeAsExampleMethod -- do not edit."

	<gtExample>
	<noTest>
	<storedScenery>
	<return: #GtScenery>
	| scenery item1 |
	scenery := GtScenery new.
	item1 := scenery
			addItem: (GtSceneryUMLClassStencil new
					label: 'GtScenery';
					width: 75.74499003092455) asItem.
	item1 position: 96.35630289713549 @ 191.2457987467448.
	item1 extent: 75.74499003092455 @ 28.0.
	scenery
		storeStringMethodName: 'GtSceneryStoreStringExamples>>#gtSceneryClassScenery'.
	^ scenery
]

{ #category : #example }
GtSceneryStoreStringExamples >> gtSceneryClassSceneryRestored [
	<gtExample>
	<return: #GtScenery>
	| scenery |
	scenery := self gtSceneryClassScenery.
	self assert: scenery equals: scenery restored.
	^ scenery
]

{ #category : #scenery }
GtSceneryStoreStringExamples >> inspectorOn42Scenery [
	"NB: Generated by GtScenery>>#storeAsExampleMethod -- do not edit."

	<gtExample>
	<noTest>
	<storedScenery>
	<return: #GtScenery>
	| scenery item1 |
	scenery := GtScenery new.
	item1 := scenery addItem: (GtSceneryInspectorStencil new target: [ 42 ]) asItem.
	item1 position: -105.833251953125 @ 192.30275472005212.
	item1 extent: 355.784912109375 @ 202.16888427734375.
	scenery
		storeStringMethodName: 'GtSceneryStoreStringExamples>>#inspectorOn42Scenery'.
	^ scenery
]

{ #category : #example }
GtSceneryStoreStringExamples >> inspectorOn42SceneryRestored [
	<gtExample>
	<return: #GtScenery>
	| scenery item1 |
	scenery := self inspectorOn42Scenery.
	item1 := scenery items first.
	self
		assert: item1 stencil storeString
		equals: 'GtSceneryInspectorStencil new target: [ 42 ]'.
	self assert: scenery equals: scenery restored.
	^ scenery
]

{ #category : #example }
GtSceneryStoreStringExamples >> inspectorOn42SceneryWithSpawnedObject [
	<gtExample>
	<return: #GtScenery>
	| scenery item42 itemByteString42 itemBubble connection |
	scenery := self inspectorOn42Scenery.
	item42 := scenery items first.
	itemByteString42 := scenery
			spawnNewItemFrom: item42
			for: item42 stencil targetValue printString.
	itemBubble := scenery
			addItem: (GtSceneryMindMapNodeStencil new label: 'Connect me to the spawned object')
					asItem.
	connection := scenery
			addConnectionWithStencil: (GtSceneryStraightArcStencil new
					curvatureFraction: 0)
			from: itemBubble
			to: itemByteString42.

	self assert: connection from equals: itemBubble.
	self assert: connection to equals: itemByteString42.
	^ scenery
]

{ #category : #'as yet unclassified' }
GtSceneryStoreStringExamples >> inspectorWithSpawnedObjects [
	<gtExample>
	<return: #GtScenery>
	| scenery item42 itemLudo itemByteString42 itemLudoPlayer |
	scenery := self sceneryWithTwoInspectors.
	item42 := scenery items first.
	itemByteString42 := scenery
			spawnNewItemFrom: item42
			for: item42 stencil targetValue printString.
	itemLudo := scenery items second.
	itemLudoPlayer := scenery
			spawnNewItemFrom: itemLudo
			for: itemLudo stencil targetValue players second.

	self assert: itemByteString42 stencil targetValue implementsStoreOn.
	self assert: itemLudoPlayer stencil targetValue implementsStoreOn not.

	^ scenery
]

{ #category : #'as yet unclassified' }
GtSceneryStoreStringExamples >> inspectorWithSpawnedObjectsRestored [
	"The spawned items are the third and last ones.
	The restored ByteString should be ok because it has a proper storeString,
	but the restored Ludo player is expected to be broken because it lacks a storeString."

	<gtExample>
	<return: #GtScenery>
	| scenery restored |
	scenery := self inspectorWithSpawnedObjects.
	restored := scenery restored.

	self assert: (scenery items third stencil targetValue isKindOf: ByteString).
	self assert: (restored items third stencil targetValue isKindOf: ByteString).

	self assert: (scenery items last stencil targetValue isKindOf: GtLudoPlayer).
	self should: [ restored items last stencil targetValue ] raise: Error.

	^ restored
]

{ #category : #example }
GtSceneryStoreStringExamples >> invalidStoreStringMethodNames [
	"Examples of method names that should not be used to set GtScenery>>#storeStringMethodName:"

	<gtExample>
	<return: #Array>
	^ {'ClassWithoutMethodSelector'.
		'Class >> #withSpacesBeforeSelector'.
		'invalidClassName>>#name'.
		'NonExistentClass666>>#name'.
		'GtSceneryStoreStringExamples>>#0invalidSelector'.
		'GtSceneryStoreStringExamples>>#not:a:unary:selector:'.
		'GtSceneryStoreStringExamples>>#notAGtExampleMethod'.
		'GtSceneryStoreStringExamples>>#gtExampleMethodWithoutNoTestPragma'}
]

{ #category : #scenery }
GtSceneryStoreStringExamples >> mindmapBubbleScenery [
	"NB: Generated by GtScenery>>#storeAsExampleMethod -- do not edit."

	<gtExample>
	<noTest>
	<storedScenery>
	<return: #GtScenery>
	| scenery item1 |
	scenery := GtScenery new.
	item1 := scenery
			addItem: (GtSceneryMindMapNodeStencil new
					label: 'A mind map bubble';
					width: 126.5262896560282) asItem.
	item1 position: 5.5452868217392215 @ 973.7566582612488.
	item1 extent: 126.5262896560282 @ 28.0.
	scenery
		storeStringMethodName: 'GtSceneryStoreStringExamples>>#mindmapBubbleScenery'.
	^ scenery
]

{ #category : #example }
GtSceneryStoreStringExamples >> mindmapBubbleSceneryRestored [
	<gtExample>
	<return: #GtScenery>
	| scenery |
	scenery := self mindmapBubbleScenery.
	self assert: scenery equals: scenery restored.
	^ scenery
]

{ #category : #private }
GtSceneryStoreStringExamples >> notAGtExampleMethod [
	^ GtScenery new 
]

{ #category : #scenery }
GtSceneryStoreStringExamples >> reflectionPageScenery [
	"NB: Generated by GtScenery>>#storeAsExampleMethod -- do not edit."

	<gtExample>
	<noTest>
	<storedScenery>
	<return: #GtScenery>
	| scenery item1 |
	scenery := GtScenery new.
	item1 := scenery
			addItem: (GtSceneryLepiterPageStencil new
					pageName: 'What is Reflection?';
					databaseName: 'Glamorous Toolkit Book') asItem.
	item1 position: 308.2518561989734 @ 186.20015462239587.
	item1 extent: 642.6399739583333 @ 524.3717447916667.
	scenery
		storeStringMethodName: 'GtSceneryStoreStringExamples>>#reflectionPageScenery'.
	^ scenery
]

{ #category : #example }
GtSceneryStoreStringExamples >> reflectionPageSceneryRestored [
	<gtExample>
	<return: #GtScenery>
	| scenery |
	scenery := self reflectionPageScenery.
	self assert: scenery equals: scenery restored.
	^ scenery
]

{ #category : #scenery }
GtSceneryStoreStringExamples >> sceneryWithCheckedInvalidStoreStringMethodNames [
	"Check that invalid names are rejected."

	<gtExample>
	<return: #GtScenery>
	| scenery |
	scenery := GtScenery new.
	self invalidStoreStringMethodNames
		do: [ :methodName | 
			self
				should: [ scenery storeStringMethodFor: methodName ]
				raise: AssertionFailure ].
	^ scenery
]

{ #category : #scenery }
GtSceneryStoreStringExamples >> sceneryWithTwoInspectors [
	<gtExample>
	<return: #GtScenery>
	| scenery item1 item2 |
	scenery := GtScenery new.
	item1 := scenery addItem: (GtSceneryInspectorStencil new target: [ 42 ]) asItem.
	item1 position: -105.833251953125 @ 192.30275472005212.
	item1 extent: 355.784912109375 @ 202.16888427734375.
	item2 := scenery
			addItem: (GtSceneryInspectorStencil new target: [ GtLudoGame new ]) asItem.
	item2 position: -147.33489944273072 @ 446.9537569676901.
	item2 extent: 200.0 @ 400.0.
	^ scenery
]

{ #category : #example }
GtSceneryStoreStringExamples >> sceneryWithTwoInspectorsAndSelectedViews [
	"Check that selected views persist."

	<gtExample>
	<return: #GtScenery>
	| scenery restored |
	scenery := self sceneryWithTwoInspectors.
	scenery items first stencil viewMethodSelector: #gtPrintFor:.
	scenery items second stencil viewMethodSelector: #gtPositionsFor:.
	restored := scenery restored.

	self
		assert: restored items first stencil viewMethodSelector
		equals: #gtPrintFor:.
	self
		assert: restored items second stencil viewMethodSelector
		equals: #gtPositionsFor:.

	^ restored
]

{ #category : #scenery }
GtSceneryStoreStringExamples >> sceneryWithValidStoreStringMethodName [
	"Check that the scenery of the existing method is loaded."

	<gtExample>
	<return: #GtScenery>
	| scenery |
	scenery := GtScenery new.
	self assert: scenery items size equals: 0.
	scenery
		storeStringMethodName: 'GtSceneryStoreStringExamples>>#validStoreStringMethod'.
	scenery addSceneryFromStoreStringMethod.
	self assert: scenery items size equals: 1.
	^ scenery
]

{ #category : #scenery }
GtSceneryStoreStringExamples >> textLabelScenery [
	"NB: Generated by GtScenery>>#storeAsExampleMethod -- do not edit."

	<gtExample>
	<noTest>
	<storedScenery>
	<return: #GtScenery>
	| scenery item1 item2 |
	scenery := GtScenery new.
	item1 := scenery
			addItem: (GtSceneryTextLabelStencil new
					label: 'I am a text label';
					width: 101.5040283203125) asItem.
	item1 position: 174.287618001302 @ 188.26188151041669.
	item1 extent: 101.5040283203125 @ 28.0.
	item2 := scenery
			addItem: (GtSceneryTextLabelStencil new
					label: 'Me too!';
					width: 53.67999267578125) asItem.
	item2 position: 254.0374755859375 @ 291.11924235026044.
	item2 extent: 53.67999267578125 @ 28.0.
	scenery
		storeStringMethodName: 'GtSceneryStoreStringExamples>>#textLabelScenery'.
	^ scenery
]

{ #category : #example }
GtSceneryStoreStringExamples >> textLabelSceneryRestored [
	<gtExample>
	<return: #GtScenery>
	| scenery |
	scenery := self textLabelScenery.	"self assert: scenery items first stencil equals: scenery restored items first stencil."
	self assert: scenery equals: scenery restored.
	^ scenery
]

{ #category : #scenery }
GtSceneryStoreStringExamples >> validStoreStringMethod [
	"NB: Generated by GtScenery>>#storeAsExampleMethod -- do not edit."

	<gtExample>
	<noTest>
	<storedScenery>
	<return: #GtScenery>
	| scenery item1 |
	scenery := GtScenery new.
	item1 := scenery
			addItem: (GtSceneryMindMapNodeStencil new
					label: 'A scenery with a single item.';
					width: 102.93202209472656) asItem.
	item1 position: 0.0 @ -96.0.
	item1 extent: 102.93202209472656 @ 46.0.
	scenery
		storeStringMethodName: 'GtSceneryStoreStringExamples>>#validStoreStringMethod'.
	^ scenery
]
